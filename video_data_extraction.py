
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 27 15:01:43 2019

@author: JYOTIBDH001
"""
import numpy as np
import cv2


def read_bin_linux(filename):
    """Reads in ATIS .bin files generated by the linux interface.
    If working with N-MNIST or N-CALTECH101 datasets, use read_dataset(filename).
    If working with recordings from the GUI, use read_aer(filename).
    Returns TD, containing:
            x: pixel x coordinate, unsigned 16bit int
            y: pixel y coordinate, unsigned 16bit int
            p: polarity value, boolean. False = off event, True = on event
            ts: timestamp in microseconds, unsigned 64bit int
            width: The width of the frame.
            height: The height of the frame.
    """

    with open(filename, 'rb') as f:
        # Strip header
        header_line = f.readline()
        print('Version:', header_line.decode("utf-8"))
        header_line = f.readline()
        header_line = header_line.decode("utf-8")
        while header_line[0] == '#':
            header_line = f.readline()
            try:
                header_line = header_line.decode("utf-8")
                print(header_line)
            except:
                print('Resolution:', header_line[0], 'X', header_line[2])
                h = header_line[2]
                w = header_line[0]
                break

        raw_data = np.fromfile(f, dtype=np.uint8)
    # file already closed since using 'with' statement
    total_events = len(raw_data)
    full_x = np.zeros(total_events)
    full_y = np.zeros(total_events)
    full_p = np.zeros(total_events)
    full_ts = np.zeros(total_events)
    full_f = np.zeros(total_events)
    TD_indices = np.zeros(total_events, dtype=np.bool_)
    total_events = 0
    buffer_location = 0
    start_evt_ind = 0

    while buffer_location < len(raw_data):
        num_events = ((raw_data[buffer_location + 3].astype(np.uint32) << 24) + (
                    raw_data[buffer_location + 2].astype(np.uint32) << 16) + (
                                  raw_data[buffer_location + 1].astype(np.uint32) << 8) + raw_data[buffer_location])
        buffer_location = buffer_location + 4
        start_time = ((raw_data[buffer_location + 3].astype(np.uint32) << 24) + (
                    raw_data[buffer_location + 2].astype(np.uint32) << 16) + (
                                  raw_data[buffer_location + 1].astype(np.uint32) << 8) + raw_data[buffer_location])
        buffer_location = buffer_location + 8
        start_time = (start_time << 16)
        # Note renaming (since original is a Python built-in):
        evt_type = raw_data[buffer_location:(buffer_location + 8 * num_events):8]
        evt_subtype = raw_data[(buffer_location + 1):(buffer_location + 8 * num_events + 1):8]
        y = (raw_data[(buffer_location + 2):(buffer_location + 8 * num_events + 2):8]).astype(np.uint16) + 256 * (
        raw_data[(buffer_location + 3):(buffer_location + 8 * num_events + 1):8]).astype(np.uint16)
        x = ((raw_data[(buffer_location + 5):(buffer_location + 8 * num_events + 4):8].astype(np.uint16) << 8) + (
        raw_data[(buffer_location + 4):(buffer_location + 8 * num_events + 3):8])).astype(np.uint16)
        ts = ((raw_data[(buffer_location + 7):(buffer_location + 8 * num_events + 6):8].astype(np.uint64) << 8) + (
        raw_data[(buffer_location + 6):(buffer_location + 8 * num_events + 5):8])).astype(np.uint64)
        buffer_location = buffer_location + num_events * 8
        ts = ts + start_time
        overflows = np.where(evt_type == 2)

        for i in range(0, len(overflows[0])):
            overflow_loc = overflows[0][i]
            ts[overflow_loc:] = ts[overflow_loc:] + 65536

        locations = np.where((evt_type == 0) | (evt_type == 3))
        TD_indices[start_evt_ind:(start_evt_ind + num_events)][locations] = True
        full_x[start_evt_ind:(start_evt_ind + num_events)] = x
        full_y[start_evt_ind:(start_evt_ind + num_events)] = y
        full_p[start_evt_ind:(start_evt_ind + num_events)] = evt_subtype
        full_ts[start_evt_ind:(start_evt_ind + num_events)] = ts
        full_f[start_evt_ind:(start_evt_ind + num_events)] = evt_type
        start_evt_ind = start_evt_ind + num_events
    TD = np.rec.array(None, dtype=[('x', np.uint16), ('y', np.uint16), ('p', np.bool_), ('ts', np.uint64)],
                      shape=(len(full_x[TD_indices])))
    # If intefacing with Matlab, 1 must be added to x and y indices.
    # due to Matlab's index convention.
    TD.x = full_x[TD_indices]  # + 1
    TD.y = full_y[TD_indices]  # + 1
    TD.ts = full_ts[TD_indices]
    TD.p = full_p[TD_indices]

    # It appears that the polarity needs to be flipped (when results are compared with Matlab output).
    # Change the polarity: 0 events become 1 events and vice versa.

    TD.p = np.abs(TD.p - 1)
    TD.height = h
    TD.width = w

    return TD


def show_td(data, wait_delay=100):
        """Displays the TD events (change detection ATIS or DVS events)
        waitDelay: milliseconds
        """
        frame_length = 24e3
        t_max = data[-1].ts
        frame_start = data[0].ts
        frame_end = data[0].ts + frame_length
        td_img = np.ones((data.height, data.width), dtype=np.uint8)
        while frame_start < t_max:
            frame_data = data[(data.ts >= frame_start) & (data.ts < frame_end)]
            if frame_data.size > 0:
                td_img.fill(128)

                # with timer.Timer() as em_playback_timer:
                for datum in np.nditer(frame_data):
                    td_img[datum['y'].item(0), datum['x'].item(0)] = datum['p'].item(0)
                # print 'prepare td frame by iterating events took %s seconds'
                # %em_playback_timer.secs

                td_img = np.piecewise(td_img, [td_img == 0, td_img == 1, td_img == 128], [0, 255, 128])
                cv2.imshow('img', td_img)

                cv2.waitKey(wait_delay)

            frame_start = frame_end + 1
            frame_end = frame_end + frame_length + 1

        cv2.destroyAllWindows()
        return
